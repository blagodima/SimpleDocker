# Simple Docker


## Contents

1. [Part 1. Готовый докер](#part-1-готовый-докер)
2. [Part 2. Операции с контейнером](#part-2-операции-с-контейнером)
2. [Part 3. Мини веб-сервер](#part-3-мини-веб-сервер)
2. [Part 4. Свой докер](#part-4-свой-докер)
2. [Part 5. Dockle](#part-5-dockle)
2. [Part 6. Базовый Docker Compose](#part-6-базовый-docker-compose)


## Part 1. Готовый докер

##### Возьми официальный докер-образ с **nginx** и выкачай его при помощи `docker pull`.
- Выкачиваем фициальный докер-образ с **nginx** при помощи `docker pull` \
![part1](./tasks/part_1/1.1.png "[1.1.png] docker pull nginx")

##### Проверь наличие докер-образа через `docker images`.
- Проверяем наличие докер-образа через `docker images` \
![part1](./tasks/part_1/1.2.png "[1.2.png] docker images")

##### Запусти докер-образ через `docker run -d [image_id|repository]`.
- Запускаем докер-образ через `docker run -d nginx` \
![part1](./tasks/part_1/1.3.png "[1.3.png] docker run -d nginx")

##### Проверь, что образ запустился через `docker ps`.
- Проверяем, что образ запустился через `docker ps` \
![part1](./tasks/part_1/1.4.png "[1.4.png] docker ps")

##### Посмотри информацию о контейнере через `docker inspect [container_id|container_name]`.
- Смотрим информацию о созданном контейнере через `docker inspect epic_feynman` \
![part1](./tasks/part_1/1.5.png "[1.5.png] docker inspect epic_feynman")

##### По выводу команды определи и помести в отчёт размер контейнера, список замапленных портов и ip контейнера.
- Размер контейнера: \
![part1](./tasks/part_1/1.6.png "[1.6.png] Размер контейнера")

- Список замапленных портов: \
![part1](./tasks/part_1/1.7.png "[1.7.png] Список замапленных портов")

- IP контейнера: \
![part1](./tasks/part_1/1.8.png "[1.8.png] IP контейнера 172.17.0.2")

##### Останови докер образ через `docker stop [container_id|container_name]`.
- Остановим докер образ через `docker stop epic_feynman` \
![part1](./tasks/part_1/1.9.png "[1.9.png] docker stop epic_feynman")

##### Проверь, что образ остановился через `docker ps`.
- Проверим, что образ остановился через `docker ps` \
![part1](./tasks/part_1/1.10.png "[1.10.png] docker ps")

##### Запусти докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду *run*.
- Запустим докер с портами и проверим, что образ запустился через `docker ps` \
![part1](./tasks/part_1/1.11.png "[1.11.png] docker run -d -p 80:80 -p 443:443 -d nginx && docker ps")

##### Проверь, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.
- Проверим, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**: \
![part1](./tasks/part_1/1.12.png "[1.12.png] Страница в браузере по адресу localhost:80")

##### Перезапусти докер контейнер через `docker restart [container_id|container_name]`.
- Перезапустим докер контейнер через `docker restart zen_pascal`: \
![part1](./tasks/part_1/1.13.png "[1.13.png] docker restart zen_pascal")

##### Проверь любым способом, что контейнер запустился.
- Проверим, что контейнер запустился через `docker ps`: \
![part1](./tasks/part_1/1.14.png "[1.14.png] docker ps")

## Part 2. Операции с контейнером

##### Прочитай конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*.
- Прочитаем конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*: \
![part2](./tasks/part_2/2.1.png "[2.1.png] конфигурационный файл nginx.conf")

##### Создай на локальной машине файл *nginx.conf*.
- Создадим на локальной машине файл *nginx.conf*.: \
![part2](./tasks/part_2/2.2.png "[2.2.png] Создаём файл nginx.conf")

##### Настрой в нем по пути */status* отдачу страницы статуса сервера **nginx**.
- Настроим в нем по пути */status* отдачу страницы статуса сервера **nginx**: \
![part2](./tasks/part_2/2.3.png "[2.3.png] Настраиваем файл nginx.conf по пути status")

##### Скопируй созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp`.
- Скопируем созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp`: \
![part2](./tasks/part_2/2.4.png "[2.4.png] Настраиваем файл nginx.conf по пути status")

##### Перезапусти **nginx** внутри докер-образа через команду *exec*.
- Перезапускаем **nginx** внутри докер-образа через команду *exec*: \
![part2](./tasks/part_2/2.5.png "[2.5.png] Перезапуск nginx внутри докер-образа через команду exec")

##### Проверь, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
- Проверяем, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**: \
![part2](./tasks/part_2/2.6.png "[2.6.png] Проверка, что по адресу отдается страничка со статусом сервера nginx")

##### Экспортируй контейнер в файл *container.tar* через команду *export*.
- Экспортируем контейнер в файл *container.tar* через команду *export*: \
![part2](./tasks/part_2/2.7.png "[2.7.png] Экспортируем контейнер в файл container.tar")

##### Останови контейнер.
- Останавливаем контейнер: \
![part2](./tasks/part_2/2.8.png "[2.8.png] Останавливаем контейнер")

##### Удали образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры.
- Проверяем список образов и удалим последний образ: \
![part2](./tasks/part_2/2.9.png "[2.9.png] Проверяем список образов и удалим последний образ")

##### Удали остановленный контейнер.
- Удаляем остановленный контейнер: \
![part2](./tasks/part_2/2.10.png "[2.10.png] Удаляем остановленный контейнер")

##### Импортируй контейнер обратно через команду *import*.
- Импортируем контейнер обратно через команду *import* и проверяем, что он вернулся обратно: \
![part2](./tasks/part_2/2.11.png "[2.11.png] Импортируем контейнер обратно и проверяем")

##### Запусти импортированный контейнер.
- Запускаем импортированный контейнер: \
![part2](./tasks/part_2/2.12.png "[2.12.png] Запускаем импортированный контейнер")

##### Проверь, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
- Проверяем, что  отдается страничка со статусом сервера **nginx**: \
![part2](./tasks/part_2/2.13.png "[2.13.png] Запускаем импортированный контейнер")

## Part 3. Мини веб-сервер

##### Напиши мини-сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello World!`.
- Напишем мини-сервер, который будет возвращать `Hello World!`: \
![part3](./tasks/part_3/images/3.1.png "[3.1.png] Мини-сервер на C, который будет возвращать Hello World!")
- Скопируем файл с кодом в докер: \
![part3](./tasks/part_3/images/3.2.png "[3.2.png] Скопируем файл с кодом в докер")

- Установим необходимые библиотеки для компиляции и работы мини-сервера: \
![part3](./tasks/part_3/images/3.3.png "[3.3.png] Установим необходимые библиотеки для компиляции и работы мини-сервера")

- Скомпилируем и запустим минис-сервер: \
![part3](./tasks/part_3/images/3.4.png "[3.4.png] Скомпилируем и запустим минис-сервер")

##### Запусти написанный мини-сервер через *spawn-fcgi* на порту 8080.
- Запустим мини-сервер через *spawn-fcgi* на порту 8080: \
![part3](./tasks/part_3/images/3.5.png "[3.5.png] Запустим мини-сервер через spawn-fcgi на порту 8080")

##### Напиши свой *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*.
- Напишем свой *nginx.conf*: \
![part3](./tasks/part_3/images/3.6.png "[3.6.png] Пишем свой nginx.conf")
- Создаём, прописываем nginx.conf, копируем его в образ, и перезапускаем: \
![part3](./tasks/part_3/images/3.7.png "[3.7.png] Создаём, прописываем nginx.conf, копируем его в образ, и перезапускаем")

##### Проверь, что в браузере по *localhost:81* отдается написанная тобой страничка.
- Проверим, что по *localhost:81* отдается написанная страничка: \
![part3](./tasks/part_3/images/3.8.png "[3.8.png] Проверяем, что по localhost:81 отдается написанная страничка")

##### Положи файл *nginx.conf* по пути *./nginx/nginx.conf* (это понадобится позже).
- Положим файл *nginx.conf* по пути *./nginx/nginx.conf*: \
![part3](./tasks/part_3/images/3.9.png "[3.9.png] Положим файл nginx.conf по пути ./nginx/nginx.conf")

## Part 4. Свой докер

#### Напиши свой докер-образ, который:
1) Собирает исходники мини сервера на FastCgi из [Части 3](#part-3-мини-веб-сервер);
2) Запускает его на 8080 порту;
3) Копирует внутрь образа написанный *./nginx/nginx.conf*;
4) Запускает **nginx**. \
_**nginx** можно установить внутрь докера самостоятельно, а можно воспользоваться готовым образом с **nginx**'ом, как базовым._

- Пропишем Dockerfile в соответствии с этими пунктами: \
![part4](./tasks/part_4/images/4.1.png "[4.1.png] Dockerfile")

##### Собери написанный докер-образ через `docker build` при этом указав имя и тег.
- Собираем написанный докер-образ: \
![part4](./tasks/part_4/images/4.2.png "[4.2.png] docker build -r server_helloworld:new")

##### Проверь через `docker images`, что все собралось корректно.
- Проверяем, что все собралось корректно: \
![part4](./tasks/part_4/images/4.3.png "[4.3.png] docker images")

##### Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а (см. [Часть 2](#part-2-операции-с-контейнером)).
- Запусти собранный докер-образ как указано выше: \
![part4](./tasks/part_4/images/4.4.png "[4.4.png] docker run -d -t -p 80:81 -v ./nginx:/nginx 72b01fdcd741 bash")
- Проверяем, что образ в докере запустился: \
![part4](./tasks/part_4/images/4.5.png "[4.5.png] Проверяем, что образ в докере запустился")

##### Проверь, что по localhost:80 доступна страничка написанного мини сервера.
- Проверяем, что по localhost:80 доступна страничка написанного мини сервера: \
![part4](./tasks/part_4/images/4.6.png "[4.6.png] localhost:80 в браузере")

##### Допиши в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.
- Допишем в *./nginx/nginx.conf* проксирование странички */status*: \
![part4](./tasks/part_4/images/4.7.png "[4.7.png] localhost:80 в браузере")

##### Перезапусти докер-образ.
- Перезапустим докер-образ: \
![part4](./tasks/part_4/images/4.8.png "[4.8.png] Перезапуск докер-образ")

*Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий*

##### Проверь, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**
- Проверим, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**: \
![part4](./tasks/part_4/images/4.9.png "[4.9.png] Страничка со статусом nginx по localhost:80/status")
- Проверим также через утилиту **curl** по localhost:81/status: \
![part4](./tasks/part_4/images/4.10.png "[4.10.png] Страничка со статусом nginx по localhost:81/status")

## Part 5. **Dockle**

Для начала установим утилиту Dockle следующим образом:

    # Получение последней версии
    VERSION=$(curl -s "https://api.github.com/repos/goodwithtech/dockle/releases/latest" | grep '"tag_name":' | -E 's/.*"v([^"]+)".*/\1/')

    # Загрузка .deb файла
    curl -Lo dockle.deb "https://github.com/goodwithtech/dockle/releases/download/v${VERSION}/le_${VERSION}_Linux-64bit.deb" 

    # Установка .deb файла
    sudo dpkg -i dockle.deb && rm dockle.deb

##### Просканируй образ из предыдущего задания через `dockle [image_id|repository]`.
- Просканируем утилитой **Dockle** образ образ `my_docker:1.0` с прошлой части: \
![part5](./tasks/part_5/images/5.1.png "[5.1.png] Результат выполнения утилиты Dockle")

##### Исправь образ так, чтобы при проверке через **dockle** не было ошибок и предупреждений.

- Добавим команду `HEALTHCHECK   --interval=5m --timeout=3s`, которая отвечает за проверку работоспособности запущенных контейнеров. Это важно для обеспечения непрерывной работы и автоматического выявления проблем:  

- Флаги `--interval=5m --timeout=3s` указывают интервал между проверками и время ожидания ответа от контейнера. В данном случае, контроль будет проводиться каждые 5 минут, и если ответ не будет получен в течение 3 секунд, проверка будет считаться неудачной

- Также добавим команду `CMD curl -f http://localhost/ || exit 1`, которая использует инструмент curl для отправки запроса к веб-серверу в контейнере по адресу http://localhost/. Если запрос вернет ошибку (например, если веб-сервер недоступен), то процесс проверки здоровья контейнера завершится с кодом 1, что означает неудачу.

- Подтвердим безопасность файлов setuid и setgid командами `chmod u-s setuid-file` и `chmod g-s setgid-file`

- Добавим необходимые команды для исправления ворнингов: \
![part5](./tasks/part_5/images/5.2.png "[5.2.png] Добавим необходимые команды для исправления ворнингов")

- Проверим билд нашего докерфайла утилитой **Dockle** после исправления: \
![part5](./tasks/part_5/images/5.3.png "[5.3.png] Успешный результат")

- После добавления в Dockerfile необходимых команд для исправления, в конечном итоге оставался один ворнинг по INFO, который также исправили через команду: `export DOCKER_CONTENT_TRUST=1` и при последующей проверке утилитой Dockle больше никаких ворнингов не выводится.

## Part 6. Базовый **Docker Compose**

##### Напиши файл *docker-compose.yml*, с помощью которого:
##### 1) Подними докер-контейнер из [Части 5](#part-5-инструмент-dockle) _(он должен работать в локальной сети, т.е. не нужно использовать инструкцию **EXPOSE** и мапить порты на локальную машину)_.
##### 2) Подними докер-контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.
- Поднимем докер-контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера: \
![part6](./tasks/part_6/images/6.1.png "[6.1.png] Проксирующий контейнер, файл nginx.conf")

##### Замапь 8080 порт второго контейнера на 80 порт локальной машины.
- Замапим 8080 порт второго контейнера на 80 порт локальной машины: \
![part6](./tasks/part_6/images/6.2.png "[6.2.png] Замапим 8080 порт второго контейнера на 80 порт локальной машины")

##### Вернемся к первой поставленной задаче и напишем файл *docker-compose.yml* с вышеописанными указаниями:
- Содержание файла *docker-compose.yaml*: \
![part6](./tasks/part_6/images/6.3.png "[6.3.png] Содержание файла docker-compose.yaml")

##### Останови все запущенные контейнеры.
- Остановим все запущенные контейнеры: \
![part6](./tasks/part_6/images/6.4.png "[6.4.png] Останавливаем все запущенные контейнеры командой docker stop")

##### Собери и запусти проект с помощью команд `docker-compose build` и `docker-compose up`.
- Соберем проект с помощью команды `docker-compose build`: \
![part6](./tasks/part_6/images/6.5.png "[6.5.png] Сборка проекта командой docker-compose build")
- Запустим проект с помощью команды `docker-compose up`: \
![part6](./tasks/part_6/images/6.6.png "[6.6.png] Запуск проекта командой docker-compose up")

##### Проверь, что в браузере по *localhost:80* отдается написанная тобой страничка, как и ранее.
- Проверим командой `curl`, что по *localhost:80* отдается написанная страничка, как и ранее: \
![part6](./tasks/part_6/images/6.7.png "[6.7.png] Проверяем командой curl")
- Проверьим в браузере: \
![part6](./tasks/part_6/images/6.8.png "[6.8.png] Проверьим в браузере")